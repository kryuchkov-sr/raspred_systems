# Лабораторная работа №5. Реализация механизмов безопасности и отказоустойчивости в распределенной системе

## Цель работы 
1. Изучить и реализовать механизмы безопасности в распределенной системе, такие 
как аутентификация и шифрование данных. 
2. Настроить и протестировать отказоустойчивость распределенной системы.

## Задачи
1. Создать сертификатов X.509 для аутентификации. 
2. Реализовать аутентификации на основе сертификатов X.509. 
3. Реализовать шифрования данных. 
4. Настроить и протестировать отказоустойчивость распределенной системы. 


## Необходимое программное обеспечение 
- Операционная система: Ubuntu 22.04.
- Язык программирования: Python 3.
- Библиотеки: Flask, cryptography. 

Репозиторий содержит:
1.  **Исходный код** (`.py` файлы).
2.  **Файл README.md**, содержащий:
    *   Описание шагов запуска
    *   Скриншоты генерации сертификатов
    *   Скриншоты успешных запросов (с шифрованием)
    *   Скриншоты состояния серверов - скрин терминала
    *   Скриншоты демонстрации отказоустойчивости (ответ от резервного сервера при падении основного)
    *   Дерево проекта


## Алгоритм решения

## Описание шагов запуска

```bash
# Обновление системы
sudo apt update && sudo apt upgrade -y
```

```bash
# Установка Python и OpenSSL
sudo apt install python3 python3-pip python3-venv openssl -y
```

```bash
# Создание виртуального окружения
python3 -m venv venv
source venv/bin/activate
```

```bash
# Установка Python-библиотек
pip install flask cryptography requests
```

**Ошибок** при установке `cryptography` не возникло, поэтому устанавливать зависимости для сборки (команда ниже) не пришлось:
```bash
sudo apt install build-essential libssl-dev libffi-dev python3-dev -y
```

### 1. Выполнение генерации сертификатов и ключей

Далее была создана инфраструктура PKI для mTLS аутентификации, так как сертификаты позволяют серверу и клиенту идентифицировать друг друга.

**Запросы на генерацию:**
```bash
chmod +x generate_certificates.sh
```
```bash
./generate_certificates.sh
```

**Файлы получившиеся на выходе:**
- `ca_cert.pem` - сертификат центра сертификации
- `server_cert.pem`, `server_key.pem` - сертификат и ключ сервера
- `client_cert.pem`, `client_key.pem` - сертификат и ключ клиента

![Сертификат 1](https://github.com/user-attachments/assets/10b015bb-4d0c-439f-9db2-1419186a610c)
![Сертификат 2](https://github.com/user-attachments/assets/0292ec85-bbae-4c38-8835-d3dab91887f4)

### 2. Генерация ключа шифрования

Создаётся симметричный ключ для шифрования данных алгоритмом Fernet. Один ключ используется для шифрования (клиент) и расшифровки (сервер).

**Входящий запрос:**
```bash
python3 generate_key.py
```

**Исходящий файл:**
- `encryption_key.txt` - ключ шифрования Fernet

![Сертификат 3](https://github.com/user-attachments/assets/6eecd821-7c2c-4e0c-9e42-d4a6fbc249d6)

### 3. Запуск системы

Для демонстрации отказоустойчивости нужно запустить 5 отдельных терминалов и проверить систему:

**Терминал 1 - Сервер 1:**
```bash
source venv/bin/activate
python3 server.py 5001
```
![Сервер 1](https://github.com/user-attachments/assets/855ca37d-cb1d-4002-869c-830f269b43ad)


**Терминал 2 - Сервер 2:**
```bash
source venv/bin/activate
python3 server.py 5002
```
![Сервер 2](https://github.com/user-attachments/assets/ae6fc7a0-9776-4dc8-9e88-d3f47e4f3936)


**Терминал 3 - Координатор:**
```bash
source venv/bin/activate
python3 coordinator.py
```
![Координатор](https://github.com/user-attachments/assets/98b193af-7342-492f-820d-0b22f79ccd38)


**Терминал 4 - Клиент 1:**
```bash
source venv/bin/activate
python3 client.py
```
![Клиент 1](https://github.com/user-attachments/assets/023920b9-f721-4881-bfb4-ce07611f71a4)


**Терминал 5 - Клиент 2**
```bash
source venv/bin/activate
python3 client2.py
```
![Клиент 2](https://github.com/user-attachments/assets/d22791b1-c685-4e18-b6b9-b1d96338b2c6)


### Результаты
1) Оба сервера активны и сервер на порте 5001 успешно выводит `127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -Decrypted data: Hello, this is encrypted data!`.
2) Координатор на порту 8000, распределяющий запросы между серверами работает и выводит в логе `127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -`.
3) Клиенты, отправляющие зашифрованные запросы работают и отправляют `[Client1] Success: {'result': 'ok'}` и `[Client2] Success: {'result': 'ok'}`.

Все этапы были выполнены и успешно работают!


### Демонстрация отказоустойчивости

Доказывает, что система может работать при отказе сервера

**Этапы демонстрации**
1. Запускаю все компоненты (как в Шаге 3)
2. Выполняю запрос от клиента - запрос обработается первым сервером
3. Остановливаю первый сервер (Ctrl+C)
4. Выполняю запрос от клиента снова

**Результат**
- Координатор автоматически переключится на второй сервер
- Запрос будет успешно обработан
- В логах координатора появится сообщение: `Server https://127.0.0.1:5001 failed: ...`

**Пример вывода при отказе первого сервера:**

**Координатор:**
```
Server https://127.0.0.1:5001 failed: Connection refused
127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -
```

**Сервер 2:**
```
127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -
Decrypted data: Hello, this is encrypted data!
```

## Проверка работы системы

### Проверка портов

```bash
netstat -tuln | grep -E '5001|5002|8000'
```

Порты 5001, 5002 (серверы) и 8000 (координатор) видны.


## Итоговый результат

1. **Безопасная система:** с шифрованием данных алгоритмом `Fernet`, mTLS аутентификация между клиентом и сервером
   - Проверка сертификатов через CA

2. **Отказоустойчивая систему:** с автопереключением между серверами и сохранением работы при отказе компонента (сервера)
   - Балансировка нагрузки


