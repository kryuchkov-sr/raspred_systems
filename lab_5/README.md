# Лабораторная работа №5. Реализация механизмов безопасности и отказоустойчивости в распределенной системе

## Цель работы 
Изучить и реализовать механизмы безопасности в распределенной системе, такие как аутентификация и шифрование данных, а также настроить и протестировать отказоустойчивость распределенной системы.

## Задачи
1. Создать сертификатов X.509 для аутентификации. 
2. Реализовать аутентификации на основе сертификатов X.509. 
3. Реализовать шифрования данных. 
4. Настроить и протестировать отказоустойчивость распределенной системы. 


## Необходимое программное обеспечение 
- Операционная система: Ubuntu 22.04.
- Язык программирования: Python 3.
- Библиотеки: Flask, cryptography. 

Репозиторий содержит:
1.  **Исходный код** (`.py` файлы).
2.  **Файл README.md**, содержащий:
    *   Описание шагов запуска
    *   Скриншоты генерации сертификатов
    *   Скриншоты успешных запросов (с шифрованием)
    *   Скриншоты состояния серверов - скрин терминала
    *   Скриншоты демонстрации отказоустойчивости (ответ от резервного сервера при падении основного)
    *   Дерево проекта


## Алгоритм решения

```bash
# Обновление системы
sudo apt update && sudo apt upgrade -y
```

```bash
# Установка Python и OpenSSL
sudo apt install python3 python3-pip python3-venv openssl -y
```

```bash
# Создание виртуального окружения
python3 -m venv venv
source venv/bin/activate
```

```bash
# Установка Python-библиотек
pip install flask cryptography requests
```

**Ошибок** при установке `cryptography` не возникло, поэтому устанавливать зависимости для сборки (команда ниже) не пришлось:
```bash
sudo apt install build-essential libssl-dev libffi-dev python3-dev -y
```

### 1. Выполнение генерации сертификатов и ключей

Далее была создана инфраструктура PKI для mTLS аутентификации, так как сертификаты позволяют серверу и клиенту идентифицировать друг друга.

**Запросы на генерацию:**
```bash
chmod +x generate_certificates.sh
```
```bash
./generate_certificates.sh
```

**Файлы получившиеся на выходе:**
- `ca_cert.pem` - сертификат центра сертификации
- `server_cert.pem`, `server_key.pem` - сертификат и ключ сервера
- `client_cert.pem`, `client_key.pem` - сертификат и ключ клиента

![Сертификат 1](https://github.com/user-attachments/assets/10b015bb-4d0c-439f-9db2-1419186a610c)
![Сертификат 2](https://github.com/user-attachments/assets/0292ec85-bbae-4c38-8835-d3dab91887f4)

### 2. Генерация ключа шифрования

Создаётся симметричный ключ для шифрования данных алгоритмом Fernet. Один ключ используется для шифрования (клиент) и расшифровки (сервер).

**Входящий запрос:**
```bash
python3 generate_key.py
```

**Исходящий файл:**
- `encryption_key.txt` - ключ шифрования Fernet

![Сертификат 3](https://github.com/user-attachments/assets/6eecd821-7c2c-4e0c-9e42-d4a6fbc249d6)

### 3. Запуск системы

Для демонстрации отказоустойчивости нужно запустить 5 отдельных терминалов и проверить систему:

**Терминал 1 - Сервер 1:**
```bash
source venv/bin/activate
python3 server.py 5001
```
![Сервер 1](https://github.com/user-attachments/assets/855ca37d-cb1d-4002-869c-830f269b43ad)


**Терминал 2 - Сервер 2:**
```bash
source venv/bin/activate
python3 server.py 5002
```
![Сервер 2](https://github.com/user-attachments/assets/ae6fc7a0-9776-4dc8-9e88-d3f47e4f3936)


**Терминал 3 - Координатор:**
```bash
source venv/bin/activate
python3 coordinator.py
```
![Координатор](https://github.com/user-attachments/assets/98b193af-7342-492f-820d-0b22f79ccd38)


**Терминал 4 - Клиент 1:**
```bash
source venv/bin/activate
python3 client.py
```
![Клиент 1](https://github.com/user-attachments/assets/023920b9-f721-4881-bfb4-ce07611f71a4)


**Терминал 5 - Клиент 2**
```bash
source venv/bin/activate
python3 client2.py
```
![Клиент 2](https://github.com/user-attachments/assets/d22791b1-c685-4e18-b6b9-b1d96338b2c6)


### Результаты
1) Оба сервера активны и сервер на порте 5001 успешно выводит `127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -Decrypted data: Hello, this is encrypted data!`.
2) Координатор на порту 8000, распределяющий запросы между серверами работает и выводит в логе `127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -`.
3) Клиенты, отправляющие зашифрованные запросы работают и отправляют `[Client1] Success: {'result': 'ok'}` и `[Client2] Success: {'result': 'ok'}`.

Все этапы были выполнены и успешно работают!


### Демонстрация отказоустойчивости

Доказывает, что система может работать при отказе сервера

**Этапы демонстрации**
`До остановки первого сервера` 
![Отказ 1](https://github.com/user-attachments/assets/7ee3fa36-1824-4017-b3eb-6d7b68787112)

`После остановки сервера на порте 5001`
![Отказ 2](https://github.com/user-attachments/assets/2603e3cf-f603-4151-ba62-b2c616dbdd22)


**Результат**
- Координатор автоматически переключился на второй сервер
- Запрос был успешно обработан
- В логах координатора появилосься сообщение: `Server https://127.0.0.1:5001 failed: ...`


### Проверка портов

```bash
netstat -tuln | grep -E '5001|5002|8000'
```
![стата](https://github.com/user-attachments/assets/9621422f-383a-467c-b013-aef587459c39)

Порты 5002 (серверы) и 8000 (координатор) видны.


## Итоговый результат

1. **Безопасная система:** с шифрованием данных алгоритмом `Fernet`, mTLS аутентификация между клиентом и сервером
   - Проверка сертификатов через CA

2. **Отказоустойчивая систему:** с автопереключением между серверами и сохранением работы при отказе компонента (сервера)
   - Балансировка нагрузки




---
# Индивидуальное задание

# Вариант 14
| №  |                             server.py                             |                                  client.py                                   |
|----|-------------------------------------------------------------------|------------------------------------------------------------------------------|
| 14 |  Модифицируйте метод get_data() для поддержки сортировки данных.  | Обновите код в файле, чтобы он мог запрашивать сортировку данных на сервере. |
---

Все действия по созданию серификатов и ключей отражены ранее поэтому в данной части обозначу, что из нового в программе появились только 2 файла  `server_var14.py` и `client_var14.py`, которые являются модифицированными версиями кодов `server.py` и `client.py` для моего **варианта  14.**

Для демонстрации работы задания необходимо запустить минимум 3 терминала и проверить систему:

**Терминал 1 - Сервер 1:**
```bash
source venv/bin/activate
python3 server_var14.py 5001
```


**Терминал 2 - Сервер 2:**
```bash
source venv/bin/activate
python3 server_var14.py 5002
```

**Терминал 3 - Координатор:**
```bash
source venv/bin/activate
python3 coordinator.py
```

**Терминал 4 - Клиент 1:**
```bash
source venv/bin/activate
python3 client_var14.py
```

**В результате получается, что запущены 2 сервера (основной и резервный), координатор и клиент, который выдаёт числа в порядке убывания через приписку `desc`, жемонстрируя необходимую сортировку**
![сортированный вывод](https://github.com/user-attachments/assets/e2b864c2-8492-4651-844e-6f8914b1d31b)

### Дерево проекта
---
Дерево проекта находится через утилиту `tree`, у которой в конце есть кусок `-L 1`, который указывает на то, что мы выводим дерево не глубже 1 уровня вложенности (дерево непосредственно папки) 
```bash
sudo apt install tree
cd ~/Downloads/ds/kryuchkov_lb_05/tree -L 1
```
![tree lb 5](https://github.com/user-attachments/assets/075c706a-c891-4cea-8256-9e12c2c18a98)


## Выводы
В ходе работы были изучены и реализованы механизмы безопасности в распределенной системе, такие как аутентификация и шифрование данных, а также настроена и протестирована отказоустойчивость распределенной системы.
