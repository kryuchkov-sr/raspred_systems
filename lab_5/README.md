# Лабораторная работа №5. Реализация механизмов безопасности и отказоустойчивости в распределенной системе

## Цель работы 
1. Изучение и реализация механизмов безопасности в распределенной системе, таких 
как аутентификация и шифрование данных. 
2. Настройка и тестирование отказоустойчивости распределенной системы.

## Задачи
1. Создание сертификатов X.509 для аутентификации. 
2. Реализация аутентификации на основе сертификатов X.509. 
3. Реализация шифрования данных. 
4. Настройка и тестирование отказоустойчивости распределенной системы. 
Необходимое программное обеспечение - Операционная система: Ubuntu 22.04. - Язык программирования: Python 3. - Библиотеки: Flask, cryptography

## Необходимое программное обеспечение 
- Операционная система: Ubuntu 22.04.
- Язык программирования: Python 3.
- Библиотеки: Flask, cryptography. 

Репозиторий содержит:
1.  **Исходный код** (`.py` файлы).
2.  **Файл README.md**, содержащий:
    *   Описание шагов запуска.
    *   Скриншоты генерации сертификатов.
    *   Скриншоты успешных запросов (с шифрованием).
    *   Скриншоты демонстрации отказоустойчивости (ответ от резервного сервера при падении основного).


## Алгоритм решения

## Подготовка и реализация

### Установка зависимостей

```bash
# Обновление системы
sudo apt update && sudo apt upgrade -y
```

```bash
# Установка Python и OpenSSL
sudo apt install python3 python3-pip python3-venv openssl -y
```

```bash
# Создание виртуального окружения
python3 -m venv venv
source venv/bin/activate
```

```bash
# Установка Python-библиотек
pip install flask cryptography requests
```

**Примечание:** Если возникают ошибки при установке `cryptography`, установите зависимости для сборки:
```bash
sudo apt install build-essential libssl-dev libffi-dev python3-dev -y
```

## Алгоритм выполнения

Генерация сертификатов и ключей

Создаю инфраструктуру PKI для mTLS аутентификации. Сертификаты позволяют серверу и клиенту идентифицировать друг друга.

**Делается:**
```bash
chmod +x generate_certificates.sh
./generate_certificates.sh
```

**Получается:**
- `ca_cert.pem` - сертификат центра сертификации
- `server_cert.pem`, `server_key.pem` - сертификат и ключ сервера
- `client_cert.pem`, `client_key.pem` - сертификат и ключ клиента

### Шаг 2. Генерация ключа шифрования

**Для чего.** Создаем симметричный ключ для шифрования данных алгоритмом Fernet. Один ключ используется для шифрования (клиент) и расшифровки (сервер).

**Что делаем:**
```bash
python3 generate_key.py
```

**Что получим:**
- `encryption_key.txt` - ключ шифрования Fernet

### Шаг 3. Запуск системы

**Для чего.** Запускаем распределенную систему с несколькими серверами для демонстрации отказоустойчивости.

**Что делаем:**

Откройте 5 терминалов и выполните команды:

**Терминал 1 - Сервер 1:**
```bash
source venv/bin/activate
python3 server.py 5001
```

**Терминал 2 - Сервер 2:**
```bash
source venv/bin/activate
python3 server.py 5002
```

**Терминал 3 - Координатор:**
```bash
source venv/bin/activate
python3 coordinator.py
```

**Терминал 4 - Клиент 1:**
```bash
source venv/bin/activate
python3 client.py
```

**Терминал 5 - Клиент 2 (опционально):**
```bash
source venv/bin/activate
python3 client2.py
```

**Что получим:**
- Два работающих сервера на портах 5001 и 5002
- Координатор на порту 8000, распределяющий запросы между серверами
- Клиенты, отправляющие зашифрованные запросы

## Демонстрация работы

### Успешный запрос

**Ожидаемый вывод:**

**Клиент:**
```
[Client1] Success: {'result': 'ok'}
```

**Координатор:**
```
127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -
```

**Сервер:**
```
127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -
Decrypted data: Hello, this is encrypted data!
```

### Демонстрация отказоустойчивости

**Для чего.** Показываем, что система продолжает работать при отказе одного сервера.

**Что делаем:**
1. Запустите все компоненты (как в Шаге 3)
2. Выполните запрос от клиента - запрос обработается первым сервером
3. Остановите первый сервер (Ctrl+C в терминале 1)
4. Выполните запрос от клиента снова

**Что получим:**
- Координатор автоматически переключится на второй сервер
- Запрос будет успешно обработан
- В логах координатора появится сообщение: `Server https://127.0.0.1:5001 failed: ...`

**Пример вывода при отказе первого сервера:**

**Координатор:**
```
Server https://127.0.0.1:5001 failed: Connection refused
127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -
```

**Сервер 2:**
```
127.0.0.1 - - [DD/MM/YYYY HH:MM:SS] "POST /api/data HTTP/1.1" 200 -
Decrypted data: Hello, this is encrypted data!
```

## Проверка работы системы

### Проверка портов

```bash
netstat -tuln | grep -E '5001|5002|8000'
```

Должны быть видны порты 5001, 5002 (серверы) и 8000 (координатор).

### Проверка логов

**При успешной работе:**
- В терминале сервера появляются логи запросов и расшифрованные данные
- В терминале координатора появляются логи переадресации запросов
- Клиент выводит результат выполнения запроса

## Зачем несколько серверов и клиентов?

**Несколько серверов (5001, 5002):**
- **Отказоустойчивость:** При падении одного сервера система продолжает работать
- **Балансировка нагрузки:** Запросы распределяются между серверами
- **Демонстрация:** Показывает автоматическое переключение координатора

**Несколько клиентов:**
- **Тестирование нагрузки:** Проверка работы системы под множественными запросами
- **Параллельные запросы:** Симуляция реальной нагрузки

**Минимальная конфигурация:**
- 2 сервера (обязательно для отказоустойчивости)
- 1 координатор (обязательно)
- 1 клиент (достаточно для базовой демонстрации)

## Итоговый результат

После выполнения лабораторной работы вы получите:

1. **Безопасную систему:**
   - mTLS аутентификация между клиентом и сервером
   - Шифрование данных алгоритмом Fernet
   - Проверка сертификатов через CA

2. **Отказоустойчивую систему:**
   - Автоматическое переключение между серверами
   - Продолжение работы при отказе одного компонента
   - Балансировка нагрузки

3. **Практический опыт:**
   - Работа с PKI и X.509 сертификатами
   - Настройка SSL/TLS соединений
   - Реализация паттерна балансировщика нагрузки
   - Понимание принципов распределенных систем


